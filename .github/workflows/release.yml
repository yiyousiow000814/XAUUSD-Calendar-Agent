name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag name (e.g., v1.2.3)"
        required: true
        type: string
      ref:
        description: "Ref to check/build from on manual runs (e.g., main or a SHA)"
        required: false
        type: string
        default: "main"
      dry_run:
        description: "Validate only (do not move tag / create PR / publish release)"
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

jobs:
  prepare:
    name: Prepare tag + version
    if: github.repository == 'yiyousiow000814/XAUUSD-Calendar-Agent' && (github.event_name != 'push' || github.actor != 'github-actions[bot]')
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.sync.outputs.tag }}
      version: ${{ steps.sync.outputs.version }}
      needs_update: ${{ steps.sync.outputs.needs_update }}
      dry_run: ${{ steps.sync.outputs.dry_run }}
      branch: ${{ steps.sync.outputs.branch }}
      base_sha: ${{ steps.base.outputs.base_sha }}
      resolved_sha: ${{ steps.finalize.outputs.resolved_sha }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.ref || github.ref }}

      - name: Capture base SHA
        id: base
        run: |
          echo "base_sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

      - name: Check APP_VERSION matches tag
        id: sync
        env:
          REF_NAME: ${{ github.ref_name }}
          INPUT_TAG: ${{ inputs.tag }}
          DRY_RUN: ${{ github.event_name == 'workflow_dispatch' && inputs.dry_run || 'false' }}
        run: |
          python - <<'PY'
          import os
          import re
          import sys

          tag = (os.environ.get("INPUT_TAG") or os.environ.get("REF_NAME") or "").strip()
          if not tag:
            print("Missing tag name.", file=sys.stderr)
            sys.exit(1)

          dry_run = (os.environ.get("DRY_RUN") or "false").strip().lower() == "true"

          version = tag[1:] if tag.startswith("v") else tag
          if not re.fullmatch(r"[0-9]+\.[0-9]+\.[0-9]+(?:[-+][0-9A-Za-z.-]+)?", version):
            print(f"Unsupported tag format: {tag}", file=sys.stderr)
            sys.exit(1)

          safe_tag = re.sub(r"[^0-9A-Za-z._-]+", "-", tag)
          branch = f"chore/release-prepare-{safe_tag}"

          path = "app/agent/version.py"
          with open(path, "r", encoding="utf-8") as f:
            text = f.read()

          m = re.search(
            r'^\s*APP_VERSION\s*=\s*["\']([^"\']+)["\']\s*$',
            text,
            flags=re.M,
          )
          if not m:
            print(f"Could not parse APP_VERSION in {path}", file=sys.stderr)
            sys.exit(1)

          current = m.group(1)
          needs_update = current != version

          out_path = os.environ["GITHUB_OUTPUT"]
          with open(out_path, "a", encoding="utf-8") as out:
            out.write(f"tag={tag}\n")
            out.write(f"version={version}\n")
            out.write(f"branch={branch}\n")
            out.write(f"needs_update={'true' if needs_update else 'false'}\n")
            out.write(f"dry_run={'true' if dry_run else 'false'}\n")

          print(f"tag={tag}")
          print(f"version={version}")
          print(f"current_app_version={current}")
          print(f"needs_update={needs_update}")
          print(f"dry_run={dry_run}")
          PY

      - name: Update APP_VERSION, move tag, push branch (if needed)
        if: steps.sync.outputs.needs_update == 'true' && steps.sync.outputs.dry_run != 'true'
        env:
          BRANCH: ${{ steps.sync.outputs.branch }}
          TAG: ${{ steps.sync.outputs.tag }}
          VERSION: ${{ steps.sync.outputs.version }}
          BASE_SHA: ${{ steps.base.outputs.base_sha }}
        run: |
          set -euo pipefail

          git checkout --detach "${BASE_SHA}"

          python - <<'PY'
          import os
          import re

          version = os.environ["VERSION"]
          path = "app/agent/version.py"
          text = open(path, "r", encoding="utf-8").read()
          updated = re.sub(
            r'^\s*APP_VERSION\s*=\s*.*$',
            f'APP_VERSION = "{version}"',
            text,
            flags=re.M,
          )
          if not updated.endswith("\n"):
            updated += "\n"
          open(path, "w", encoding="utf-8", newline="\n").write(updated)
          PY

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          tag_type="$(git cat-file -t "${TAG}" 2>/dev/null || echo "commit")"
          tag_message_file="$(mktemp)"
          if [ "${tag_type}" = "tag" ]; then
            git for-each-ref "refs/tags/${TAG}" --format='%(contents)' > "${tag_message_file}" || true
          fi

          git switch -C "${BRANCH}" "${BASE_SHA}"
          git add app/agent/version.py
          git commit -m "chore: sync APP_VERSION to tag ${TAG}"
          git push -u origin "${BRANCH}" --force-with-lease

          if [ "${tag_type}" = "tag" ]; then
            git tag -a -f "${TAG}" -F "${tag_message_file}"
          else
            git tag -f "${TAG}"
          fi
          git push origin "refs/tags/${TAG}" --force

      - name: Create or update PR (if needed)
        if: steps.sync.outputs.needs_update == 'true' && steps.sync.outputs.dry_run != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
          BRANCH: ${{ steps.sync.outputs.branch }}
          TAG: ${{ steps.sync.outputs.tag }}
          VERSION: ${{ steps.sync.outputs.version }}
        run: |
          python - <<'PY'
          import json
          import os
          import urllib.parse
          import urllib.request

          token = os.environ["GH_TOKEN"]
          owner = os.environ["OWNER"]
          repo = os.environ["REPO"]
          branch = os.environ["BRANCH"]
          tag = os.environ["TAG"]
          version = os.environ["VERSION"]

          base = "main"
          head = f"{owner}:{branch}"

          def request(method: str, url: str, payload=None):
            data = None
            if payload is not None:
              data = json.dumps(payload).encode("utf-8")
            req = urllib.request.Request(url, data=data, method=method)
            req.add_header("Authorization", f"Bearer {token}")
            req.add_header("Accept", "application/vnd.github+json")
            req.add_header("User-Agent", "release-workflow")
            if data is not None:
              req.add_header("Content-Type", "application/json; charset=utf-8")
            with urllib.request.urlopen(req) as resp:
              return json.loads(resp.read().decode("utf-8"))

          query = urllib.parse.urlencode({"head": head, "state": "open"})
          existing = request(
            "GET",
            f"https://api.github.com/repos/{owner}/{repo}/pulls?{query}",
          )
          if existing:
            print(f"PR already exists: {existing[0].get('html_url')}")
            raise SystemExit(0)

          title = f"chore(release): sync APP_VERSION to {version} ({tag})"
          body = (
            "Summary:\n"
            f"- Tag {tag} detected; updated `app/agent/version.py` so `APP_VERSION` == `{version}`.\n"
            f"- Re-pointed tag {tag} to the version-sync commit to keep the release source consistent.\n\n"
            "Notes:\n"
            "- This PR is created automatically by `.github/workflows/release.yml`.\n"
            "- Merge this PR into `main` to keep `APP_VERSION` in sync with the release tag.\n"
          )
          payload = {
            "title": title,
            "head": branch,
            "base": base,
            "body": body,
            "draft": False,
          }
          pr = request(
            "POST",
            f"https://api.github.com/repos/{owner}/{repo}/pulls",
            payload,
          )
          print(f"Created PR: {pr.get('html_url')}")
          PY

      - name: Finalize resolved SHA
        id: finalize
        run: |
          echo "resolved_sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

  build-windows:
    name: Build Setup.exe (Windows)
    needs: prepare
    if: github.repository == 'yiyousiow000814/XAUUSD-Calendar-Agent' && needs.prepare.outputs.dry_run != 'true'
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ needs.prepare.outputs.resolved_sha }}

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python build dependencies
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-app.txt

      - name: Install Inno Setup
        shell: pwsh
        run: |
          choco install innosetup -y --no-progress

      - name: Build installer
        shell: pwsh
        run: |
          .\scripts\build_installer.ps1 -RepoRoot (Resolve-Path ".")
          if (-not (Test-Path "Setup.exe")) {
            throw "Setup.exe not found after build."
          }

      - name: Upload Setup.exe artifact
        uses: actions/upload-artifact@v4
        with:
          name: setup-windows
          path: Setup.exe

  release:
    name: Publish GitHub Release
    needs:
      - prepare
      - build-windows
    if: github.repository == 'yiyousiow000814/XAUUSD-Calendar-Agent' && needs.prepare.outputs.dry_run != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download Setup.exe artifact
        uses: actions/download-artifact@v4
        with:
          name: setup-windows
          path: artifacts

      - name: Create GitHub Release (upload Setup.exe only)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare.outputs.tag }}
          name: ${{ needs.prepare.outputs.version }}
          generate_release_notes: true
          files: artifacts/Setup.exe
          fail_on_unmatched_files: true
